---
layout: mypost
title: MySQL 备忘
categories: [备忘]
---

# mysql 备忘
# 目录
- [mysql 备忘](#mysql-备忘)
- [目录](#目录)
- [日志模块](#日志模块)
  - [redo log](#redo-log)
  - [binlog](#binlog)
  - [提交过程](#提交过程)
- [事务](#事务)
  - [术语](#术语)
  - [隔离级别](#隔离级别)
  - [可重复读隔离级别实现](#可重复读隔离级别实现)
- [索引](#索引)
  - [常见索引模型](#常见索引模型)
  - [InnoDB 的索引](#innodb-的索引)
    - [覆盖索引](#覆盖索引)
    - [最左前缀原则^[https://www.cnblogs.com/xuwc/p/14007766.html]](#最左前缀原则httpswwwcnblogscomxuwcp14007766html)
    - [索引下推](#索引下推)
- [锁](#锁)
  - [全局锁](#全局锁)
  - [表级锁](#表级锁)
  - [行锁](#行锁)
  - [死锁复习](#死锁复习)
- [MVCC 工作原理](#mvcc-工作原理)
- [索引](#索引-1)

# 日志模块
## redo log
Innodb 引擎有redo log，叫WAL（Write Ahead Logging），先写日志，后写磁盘。空闲时才把日志同步到磁盘。

日志记录了物理日志，记录了在某个数据页上做了什么修改。

redo log大小固定，是类似循环队列的结构，写满了会再从头开始写。有一个write pose和checkpoint，write pose是队尾，checkpoint是队头。

## binlog
是mysql server层的日志，记录了原始操作逻辑，比如给id=2的记录自增。binlog 写到一定大小就会换一个文件去写，不会覆盖之前的日志。

## 提交过程
1. 执行器找到对应数据页，如果数据不在内存，就从外存调入
2. 执行器修改内存数据
3. Innodb 记录修改到redo log，此时redo log处于prepared状态
4. 执行器生成binlog，binlog写入磁盘
5. Innodb 把redo log改成commit状态

用两阶段提交保证了redo log和binlog的数据能对应上

# 事务
## 术语
- 脏读：A事务读取B事务尚未提交的数据
- 不可重复读：A事务第一次和第二次取到的数据不一样，即没有屏蔽update操作
- 幻读：事务A在执行读取操作，需要两次统计数据的总量，但是前后两次取到的统计量不一样

## 隔离级别
- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到
- 读提交：一个事务提交之后，它做的变更才会被其他事务看到
- 可重复读（默认）：是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，可能幻读
- 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

实现逻辑为创建一致性读视图。可重复读的一致性读视图是在事务启动时创建的，整个事务期间都在用这个一致性读视图。读提交是一条sql一个一致性读视图，读未提交是不设置一致性读视图，串行化使用读者-写者方式解决。

## 可重复读隔离级别实现
每条记录在更新的时候都会同时记录一条回滚操作，每次通过回滚操作都可以得到前一个状态的值。同一条记录在系统中可以存在多个版本，即MVCC

回滚段的结构像是一个链表，记录的是把当前值改成旧值的操作，比如：一个值从1一路被改为成2，3，4，则回滚段的内容就是：

```
将2改为1 <- 改3改为2 <- 将4改为3 （当前值是4）
```

一个回滚查询的时候，不同时刻启动的事务对应不同的视图（回滚段）

# 索引
## 常见索引模型
- hash表：一般使用链地址法，只适用于等值查询，
- 有序序列：使用二分查找，适用于修改比较少的数据（维持有序的成本高）
- B+树

## InnoDB 的索引
一个索引对应一个B+树。有两类索引：
- 主键索引（聚簇索引）：叶子节点存储整行数据
- 非主键索引（二级索引）：叶子节点存储主键的值

从非主键索引的B+树找到主键的值，然后回主键索引里找完整数据的过程叫回表。基于非主键索引的查询可能会扫描多个索引树。

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小

### 覆盖索引
比如

```sql
select ID from t1 where k between 3 and 5;
```

从k索引对应的B+树上找到了ID值，然而不需要回到主键B+树上找其他列的数据，这个过程叫覆盖索引。

附：假设没有k=4的值，从而Server层收到了2条数据，因此MySQL认为扫描行数是2

联合索引：比如一个市民表上将身份证号和名字建立联合索引。现在有一个高频请求，要根据市民的身份证号查询他的姓名。此时这个覆盖索引可以杜绝回表，从而提高性能。

### 最左前缀原则^[https://www.cnblogs.com/xuwc/p/14007766.html]
如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。比如User表的name和city加联合索引就是(name,city)

```sql
select * from user where name=xx and city=xx ; // 可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引        
```

询的时候如果两个条件都用上了，但是顺序不同，如 `city = xx and name = xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

### 索引下推
在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

比如有一个联合索引（name, age），检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”

```sql
select * from tuser where name like '张%' and age=10 and ismale=1;
```

用 张 找到了第一个满足条件的记录id=3，然后在判断其他条件是否满足时，可以从id=3处一条一条回表判断，而如果使用了索引下推技术，则不用回表了，因为索引里面就有age，因此直接判断如果索引里面的age不合条件，就直接不回表了。

# 锁
## 全局锁
对整个数据库加锁，此时整个库处于只读状态。一般用来作全库逻辑备份。mysqldump使用参数–single-transaction的时候，由于 InnoDB 有MVCC支持，这个过程是可以更新数据的。对于MyISAM引擎，不支持事务，从而只能加全局锁。

此外不能用开启只读模式来实现类似的效果，因为如果在备份时出现异常，那么只读模式将无法自动解除。

## 表级锁
会阻塞别的线程的读写，同时会限制本线程的操作。具体体现为 `lock tables t1 read, t2 write;` 后，其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

另一类表锁是MDL(metadata lock)，是读写锁，不需要显式使用，用于保证访问表时，表的结构变化了，查得的数据还是原来的表结构对应的数据。

坑：有四个session: A, B, C, D。A、B在执行select，则此时数据库加上了MDL读锁，C要准备alter table，此时C的写锁会被阻塞，D在select时要加读锁，也会被阻塞。这背后的逻辑是读者写者问题，使用写进程优先的策略，即读进程count+1操作的外面套了一层写操作的互斥（对w进行P操作），C在写时对w进行了P操作，但是阻塞在了rw的P操作上，D在进入时卡在了w的P操作上。（见22版王道书操作系统87页）注：此处的读操作、写操作指的是对表结构的读写

解决方法：
- 暂停DDL或杀死长进程
- 为alter table操作加上等待时间阻止（有专门的SQL语句）

## 行锁
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

例子：

顾客A要在影院B购买电影票
1. 从顾客A账户余额中扣除电影票价；(update)
2. 给影院B的账户余额增加这张电影票价；(update)
3. 记录一条交易日志。(insert)

如果有另一顾客要买票，此时语句2会导致加锁。因此语句2应该往后放，即把以上顺序改为3、1、2

## 死锁复习
四个必要条件：互斥条件、不可剥夺条件、请求且保持条件、循环等待条件

三种处理策略：
- 死锁预防：破坏必要条件
- 死锁避免：是死锁预防和死锁检测的折中，即在运行时判断是否可能死锁（银行家算法）
- 死锁检测

死锁预防：
- 破坏互斥条件：将资源改为共享型，如使用SPOOLing技术
- 破坏不可剥夺条件：释放已有资源，常用于易于保存和恢复的资源，如CPU的寄存器
- 破坏请求且保持条件：预先静态分配方法，进程在运行之前一次性分配所有资源
- 破坏循环等待条件：顺序资源分配法，给资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完

死锁避免：分配资源之前计算此分配的安全性，防止系统进入不安全状态。

死锁检测：
- 资源剥夺法：挂起死锁进程，抢占其资源，分配给其他死锁进程
- 撤销进程法：强制撤销部分甚至全部死锁进程
- 进程回退法：让进程回退到足以回避死锁的地步，要求系统可以保持进程的历史信息，设置还原点

# MVCC 工作原理
begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 

两种视图：
- view，就是正常的视图
- MVCC 用到的一致性读视图

MVCC 是基于整个库的，事务启动时拍快照。一个事务有一个自增事务id，一行数据也有一个事务id叫row trx_id ，就是更新数据时的所在的那个事务的id。也即一行数据有多个版本，每个版本有一个自己的row trx_id。

InnoDB为每个事务构造了一个数组，用来保存此事务启动时，所有已开启但是还没提交的事务。数组里的最小事务id叫低水位，也就是本事务开启时已经提交了的事务；当前系统里面已经创建过的事务ID的最大值加1记为高水位，也就是未开始的事务。

> 可重复读的定义：一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后这个事务执行期间，其他事务的更新对它不可见，自己的更新始终能看见

因此在读数据时，如果这个数据的row trx_id 低于低水位，就可以使用，否则就顺着数据的更新记录往回找，直到找到一个row trx_id 低于低水位的数据，然后拿出来用。（这个数组是干什么的目前意义不明，讲义上说可能出现row trx_id处对应数据于未提交状态但是不在数组中的情况，此时的数据也是可以用的。但是我迟迟想不通什么情况下才可能不在数组中）

更新数据时是先读后写的，读时只能读到当前最新的数据。也就是B事务在开启事务后，update数据前，有一条C语句update（没有事务）执行了，那么此时B在update时读到的是C更新之后的值。而如果C是一个事务，并且在B进行update之前还没有提交，那么B就会被阻塞，直到C被提交了

# 索引
索引内部是b+树，数据是有序存放的。数据分页存放，一页默认16KB，一次从磁盘中读一页内容

对于
```sql
select id from tb where k = 5;
```
**查询**

k上有索引。普通索引查找过程：查找到满足条件的第一个记录，然后继续往下找，直到第一个不萍踪条件的记录出现。唯一键索引查找过程：查找到满足条件的第一个记录后立即停止

**更新**

